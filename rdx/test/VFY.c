//
// rdxVerify property tests
//
#include "RDX.h"

#include "abc/01.h"
#include "abc/PRO.h"
#include "abc/TEST.h"

// Error codes for verification (generated by ok64 utility)
con ok64 VFYBADTYPE = 0x7cf88b28d76264e;    // bad TLV type literal
con ok64 VFYBADLEN = 0x1f3e22ca355397;      // bad record length
con ok64 VFYBADUTF8 = 0x7cf88b28d79d3c8;    // invalid UTF-8
con ok64 VFYBADTERM = 0x7cf88b28d74e6d6;    // invalid term (non-Base64)
con ok64 VFYBADINT = 0x1f3e22ca3525dd;      // invalid integer encoding
con ok64 VFYBADFL = 0x7cf88b28d3d5;         // NaN or invalid float
con ok64 VFYBADREF = 0x1f3e22ca35b38f;      // invalid reference
con ok64 VFYBADNEST = 0x7cf88b28d5ce71d;    // bad nesting
con ok64 VFYBADORD = 0x1f3e22ca3586cd;      // incorrect element order

// Test case structure: input TLV bytes, expected result, description
typedef struct {
    u8 data[32];
    u8 len;
    ok64 expect;
    char const* desc;
} VFYcase;

// RON Base64 alphabet: 0-9 A-Z _ a-z ~
// Valid: [0-9A-Za-z_~]

con VFYcase VERIFY_CASES[] = {
    // === VALID CASES ===

    // Empty integer (value 0)
    {{0x69, 0x01, 0x00}, 3, OK, "int 0"},

    // Integer 1 (zig-zag: 1 -> 2)
    {{0x69, 0x02, 0x00, 0x02}, 4, OK, "int 1"},

    // Integer -1 (zig-zag: -1 -> 1)
    {{0x69, 0x02, 0x00, 0x01}, 4, OK, "int -1"},

    // Integer 65536 (zig-zag: 65536 -> 131072 = 0x20000, needs 4 bytes)
    {{0x69, 0x05, 0x00, 0x00, 0x00, 0x02, 0x00}, 7, OK, "int 65536"},

    // Float 0.0 (empty payload after id-len byte)
    {{0x66, 0x01, 0x00}, 3, OK, "float 0.0"},

    // Float with 2-byte payload
    {{0x66, 0x03, 0x00, 0x00, 0x3f}, 5, OK, "float small"},

    // Reference 0-0 (empty)
    {{0x72, 0x01, 0x00}, 3, OK, "ref 0-0"},

    // Reference with 2 bytes (1+1 encoding)
    {{0x72, 0x03, 0x00, 0x04, 0x05}, 5, OK, "ref small"},

    // Empty string
    {{0x73, 0x01, 0x00}, 3, OK, "string empty"},

    // String "Hi" (ASCII, valid UTF-8)
    {{0x73, 0x03, 0x00, 'H', 'i'}, 5, OK, "string Hi"},

    // String with UTF-8 2-byte char (ñ = 0xc3 0xb1)
    {{0x73, 0x03, 0x00, 0xc3, 0xb1}, 5, OK, "string utf8-2"},

    // String with UTF-8 3-byte char (€ = 0xe2 0x82 0xac)
    {{0x73, 0x04, 0x00, 0xe2, 0x82, 0xac}, 6, OK, "string utf8-3"},

    // Term "null" (valid Base64)
    {{0x74, 0x05, 0x00, 'n', 'u', 'l', 'l'}, 7, OK, "term null"},

    // Term "true"
    {{0x74, 0x05, 0x00, 't', 'r', 'u', 'e'}, 7, OK, "term true"},

    // Term "A1_z~" (all valid RON Base64 chars)
    {{0x74, 0x06, 0x00, 'A', '1', '_', 'z', '~'}, 8, OK, "term base64"},

    // Empty tuple
    {{0x70, 0x01, 0x00}, 3, OK, "tuple empty"},

    // Tuple with one integer
    {{0x70, 0x05, 0x00, 0x69, 0x02, 0x00, 0x02}, 7, OK, "tuple (1)"},

    // Empty linear container
    {{0x6c, 0x01, 0x00}, 3, OK, "linear empty"},

    // Empty Euler set
    {{0x65, 0x01, 0x00}, 3, OK, "euler empty"},

    // Empty multiplexed container
    {{0x78, 0x01, 0x00}, 3, OK, "multix empty"},

    // Nested: tuple containing empty tuple
    // Outer: 'p'=0x70, len=4, idlen=0, inner='p'=0x70, len=1, idlen=0
    {{0x70, 0x04, 0x00, 0x70, 0x01, 0x00}, 6, OK, "nested tuple"},

    // === INVALID CASES ===

    // Invalid UTF-8: lone continuation byte
    {{0x73, 0x02, 0x00, 0x80}, 4, VFYBADUTF8, "utf8 lone cont"},

    // Invalid UTF-8: truncated 2-byte sequence
    {{0x73, 0x02, 0x00, 0xc3}, 4, VFYBADUTF8, "utf8 trunc 2"},

    // Invalid UTF-8: truncated 3-byte sequence
    {{0x73, 0x03, 0x00, 0xe2, 0x82}, 5, VFYBADUTF8, "utf8 trunc 3"},

    // Invalid UTF-8: overlong encoding of ASCII
    {{0x73, 0x03, 0x00, 0xc0, 0xaf}, 5, VFYBADUTF8, "utf8 overlong"},

    // Invalid UTF-8: surrogate half (0xed 0xa0 0x80 = U+D800)
    {{0x73, 0x04, 0x00, 0xed, 0xa0, 0x80}, 6, VFYBADUTF8, "utf8 surrogate"},

    // Invalid term: contains space (not Base64)
    {{0x74, 0x03, 0x00, 'a', ' '}, 5, VFYBADTERM, "term space"},

    // Invalid term: contains '!' (not RON Base64)
    {{0x74, 0x02, 0x00, '!'}, 4, VFYBADTERM, "term bang"},

    // Invalid term: contains '#'
    {{0x74, 0x02, 0x00, '#'}, 4, VFYBADTERM, "term hash"},

    // Float NaN: 0x7ff8000000000000 -> flipped 0xf87f -> zip 2 bytes: 7f f8
    {{0x66, 0x03, 0x00, 0x7f, 0xf8}, 5, VFYBADFL, "float NaN"},

    // Sentinel: empty entry marks end of table
    {{0}, 0, 0, NULL},
};

// Test cases for rdxVerifyAll (sequences with nested content)
con VFYcase VERIFYALL_CASES[] = {
    // Nested tuple with bad UTF-8 string inside
    // tuple( string("\x80") )
    {{0x70, 0x05, 0x00, 0x73, 0x02, 0x00, 0x80}, 7, VFYBADUTF8, "nested bad utf8"},

    // Nested tuple with bad term inside
    // tuple( term("!") )
    {{0x70, 0x05, 0x00, 0x74, 0x02, 0x00, '!'}, 7, VFYBADTERM, "nested bad term"},

    // Nested tuple with NaN float inside
    // tuple( float(NaN) )
    {{0x70, 0x06, 0x00, 0x66, 0x03, 0x00, 0x7f, 0xf8}, 8, VFYBADFL, "nested NaN"},

    // Valid nested structure: tuple( int(1), string("x") )
    {{0x70, 0x09, 0x00, 0x69, 0x02, 0x00, 0x02, 0x73, 0x02, 0x00, 'x'},
     11,
     OK,
     "nested valid"},

    // Sentinel
    {{0}, 0, 0, NULL},
};

ok64 VERIFYtest() {
    sane(1);

    // Test rdxVerify (single element)
    for (int i = 0; VERIFY_CASES[i].desc != NULL; i++) {
        VFYcase const* tc = &VERIFY_CASES[i];

        // Setup iterator with test data
        u8c const* data = tc->data;
        u8cs slice = {data, data + tc->len};

        rdx it = {.format = RDX_FMT_TLV};
        u8csMv(it.data, slice);

        // Parse the element first
        ok64 parse_result = rdxNext(&it);

        ok64 result;
        if (parse_result != OK) {
            // Parse failed - use parse error as result
            result = parse_result;
        } else {
            // Parse succeeded - verify current element
            result = rdxVerify(&it);
        }

        // Check result matches expectation
        if (result != tc->expect) {
            trace("FAIL[%d] %s: got %s", i, tc->desc, ok64str(result));
            trace(", want %s\n", ok64str(tc->expect));
            fail(TESTfail);
        }
        trace("PASS[%d] %s\n", i, tc->desc);
    }

    // Test rdxVerifyAll (sequences with nesting)
    for (int i = 0; VERIFYALL_CASES[i].desc != NULL; i++) {
        VFYcase const* tc = &VERIFYALL_CASES[i];

        u8c const* data = tc->data;
        u8cs slice = {data, data + tc->len};

        rdx it = {.format = RDX_FMT_TLV};
        u8csMv(it.data, slice);

        ok64 result = rdxVerifyAll(&it);

        if (result != tc->expect) {
            trace("FAIL[all:%d] %s: got %s", i, tc->desc, ok64str(result));
            trace(", want %s\n", ok64str(tc->expect));
            fail(TESTfail);
        }
        trace("PASS[all:%d] %s\n", i, tc->desc);
    }

    done;
}

TEST(VERIFYtest);
