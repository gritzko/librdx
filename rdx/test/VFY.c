//
// rdxVerify property tests
//
#include "RDX.h"
#include "abc/01.h"
#include "abc/PRO.h"
#include "abc/TEST.h"

// Error codes for verification (generated by ok64 utility)
con ok64 VFYBADTYPE = 0x7cf88b28d76264e;  // bad TLV type literal
con ok64 VFYBADLEN = 0x1f3e22ca355397;    // bad record length
con ok64 VFYBADUTF8 = 0x7cf88b28d79d3c8;  // invalid UTF-8
con ok64 VFYBADTERM = 0x7cf88b28d74e6d6;  // invalid term (non-Base64)
con ok64 VFYBADINT = 0x1f3e22ca3525dd;    // invalid integer encoding
con ok64 VFYBADFL = 0x7cf88b28d3d5;       // NaN or invalid float
con ok64 VFYBADREF = 0x1f3e22ca35b38f;    // invalid reference
con ok64 VFYBADNEST = 0x7cf88b28d5ce71d;  // bad nesting
con ok64 VFYBADORD = 0x1f3e22ca3586cd;    // incorrect element order

// Error codes from abc (already defined in headers, just reference here)
// RDXBAD, TLVbadkv, ZINTBAD are used in test cases

// Test case structure: input TLV bytes, expected result, description
typedef struct {
    u8 data[32];
    u8 len;
    ok64 expect;
    char const* desc;
} VFYcase;

// RON Base64 alphabet: 0-9 A-Z _ a-z ~
// Valid: [0-9A-Za-z_~]

con VFYcase VERIFY_CASES[] = {
    // === VALID CASES ===

    // Empty integer (value 0)
    {{0x69, 0x01, 0x00}, 3, OK, "int 0"},

    // Integer 1 (zig-zag: 1 -> 2)
    {{0x69, 0x02, 0x00, 0x02}, 4, OK, "int 1"},

    // Integer -1 (zig-zag: -1 -> 1)
    {{0x69, 0x02, 0x00, 0x01}, 4, OK, "int -1"},

    // Integer 65536 (zig-zag: 65536 -> 131072 = 0x20000, needs 4 bytes)
    {{0x69, 0x05, 0x00, 0x00, 0x00, 0x02, 0x00}, 7, OK, "int 65536"},

    // Float 0.0 (empty payload after id-len byte)
    {{0x66, 0x01, 0x00}, 3, OK, "float 0.0"},

    // Float with 2-byte payload
    {{0x66, 0x03, 0x00, 0x00, 0x3f}, 5, OK, "float small"},

    // Reference 0-0 (empty)
    {{0x72, 0x01, 0x00}, 3, OK, "ref 0-0"},

    // Reference with 2 bytes (1+1 encoding)
    {{0x72, 0x03, 0x00, 0x04, 0x05}, 5, OK, "ref small"},

    // Empty string
    {{0x73, 0x01, 0x00}, 3, OK, "string empty"},

    // String "Hi" (ASCII, valid UTF-8)
    {{0x73, 0x03, 0x00, 'H', 'i'}, 5, OK, "string Hi"},

    // String with UTF-8 2-byte char (ñ = 0xc3 0xb1)
    {{0x73, 0x03, 0x00, 0xc3, 0xb1}, 5, OK, "string utf8-2"},

    // String with UTF-8 3-byte char (€ = 0xe2 0x82 0xac)
    {{0x73, 0x04, 0x00, 0xe2, 0x82, 0xac}, 6, OK, "string utf8-3"},

    // Term "null" (valid Base64)
    {{0x74, 0x05, 0x00, 'n', 'u', 'l', 'l'}, 7, OK, "term null"},

    // Term "true"
    {{0x74, 0x05, 0x00, 't', 'r', 'u', 'e'}, 7, OK, "term true"},

    // Term "A1_z~" (all valid RON Base64 chars)
    {{0x74, 0x06, 0x00, 'A', '1', '_', 'z', '~'}, 8, OK, "term base64"},

    // Empty tuple
    {{0x70, 0x01, 0x00}, 3, OK, "tuple empty"},

    // Tuple with one integer
    {{0x70, 0x05, 0x00, 0x69, 0x02, 0x00, 0x02}, 7, OK, "tuple (1)"},

    // Empty linear container
    {{0x6c, 0x01, 0x00}, 3, OK, "linear empty"},

    // Empty Euler set
    {{0x65, 0x01, 0x00}, 3, OK, "euler empty"},

    // Empty multiplexed container
    {{0x78, 0x01, 0x00}, 3, OK, "multix empty"},

    // Nested: tuple containing empty tuple
    // Outer: 'p'=0x70, len=4, idlen=0, inner='p'=0x70, len=1, idlen=0
    {{0x70, 0x04, 0x00, 0x70, 0x01, 0x00}, 6, OK, "nested tuple"},

    // === INVALID CASES ===

    // Invalid UTF-8: lone continuation byte
    {{0x73, 0x02, 0x00, 0x80}, 4, VFYBADUTF8, "utf8 lone cont"},

    // Invalid UTF-8: truncated 2-byte sequence
    {{0x73, 0x02, 0x00, 0xc3}, 4, VFYBADUTF8, "utf8 trunc 2"},

    // Invalid UTF-8: truncated 3-byte sequence
    {{0x73, 0x03, 0x00, 0xe2, 0x82}, 5, VFYBADUTF8, "utf8 trunc 3"},

    // Invalid UTF-8: overlong encoding of ASCII
    {{0x73, 0x03, 0x00, 0xc0, 0xaf}, 5, VFYBADUTF8, "utf8 overlong"},

    // Invalid UTF-8: surrogate half (0xed 0xa0 0x80 = U+D800)
    {{0x73, 0x04, 0x00, 0xed, 0xa0, 0x80}, 6, VFYBADUTF8, "utf8 surrogate"},

    // Invalid term: contains space (not Base64)
    {{0x74, 0x03, 0x00, 'a', ' '}, 5, VFYBADTERM, "term space"},

    // Invalid term: contains '!' (not RON Base64)
    {{0x74, 0x02, 0x00, '!'}, 4, VFYBADTERM, "term bang"},

    // Invalid term: contains '#'
    {{0x74, 0x02, 0x00, '#'}, 4, VFYBADTERM, "term hash"},

    // Float NaN: 0x7ff8000000000000 -> flipped 0xf87f -> zip 2 bytes: 7f f8
    {{0x66, 0x03, 0x00, 0x7f, 0xf8}, 5, VFYBADFL, "float NaN"},

    // Float +Infinity: 0x7ff0000000000000 -> flipped -> zip 2 bytes: 7f f0
    {{0x66, 0x03, 0x00, 0x7f, 0xf0}, 5, VFYBADFL, "float +Inf"},

    // Float -Infinity: 0xfff0000000000000 -> flipped -> zip 2 bytes: ff f0
    {{0x66, 0x03, 0x00, 0xff, 0xf0}, 5, VFYBADFL, "float -Inf"},

    // === FUZZER-DISCOVERED CASES ===

    // Invalid type literal 'c' (0x63) - not a valid RDX type
    {{0x63, 0x02, 0x00, 0x23}, 4, RDXBAD, "fuzz: invalid type 'c'"},

    // Empty term (terms cannot be empty)
    {{0x74, 0x01, 0x00}, 3, VFYBADTERM, "fuzz: empty term"},

    // Non-canonical: long form 'R' when short 'r' would work
    // R(0x52) len=0x01000000(LE)=1, idlen=0 - payload 1 byte, should use short
    {{0x52, 0x01, 0x00, 0x00, 0x00, 0x00}, 6, RDXBAD, "fuzz: overlong TLV"},

    // Non-canonical: huge form when long would work
    // '2'(0x32) is huge form of 'R', 8-byte LE len=2, small payload
    {{0x32, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
     11,
     RDXBAD,
     "fuzz: huge form"},

    // Invalid TLV: idlen claims more bytes than available
    // 'x' len=1 body=[0x01] but idlen=1 means 1 byte of id, leaving no room
    {{0x78, 0x01, 0x01}, 3, TLVbadkv, "fuzz: idlen overflow"},

    // Non-canonical ZINT: int 0 encoded as 1 byte instead of 0 bytes
    // 'i' len=4, idlen=2, id=0x00 0x10, value=0x00 (should be empty for 0)
    {{0x69, 0x04, 0x02, 0x00, 0x10, 0x00}, 6, ZINTBAD, "fuzz: overlong int"},

    // Term starting with digit (ambiguous with integers in JDR)
    {{0x74, 0x02, 0x00, '4'}, 4, VFYBADTERM, "fuzz: term starts digit"},

    // Ref value exceeds 60-bit limit (upper 4 bits reserved)
    // ref with seq > 0x0FFFFFFFFFFFFFFF
    {{0x72, 0x0d, 0x00, 0x62, 0x27, 0x01, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff,
      0x00, 0x66, 0x21},
     15,
     VFYBADREF,
     "fuzz: ref exceeds 60 bits"},

    // Sentinel: empty entry marks end of table
    {{0}, 0, 0, NULL},
};

// Test cases for rdxVerifyAll (sequences with nested content)
con VFYcase VERIFYALL_CASES[] = {
    // Nested tuple with bad UTF-8 string inside
    // tuple( string("\x80") )
    {{0x70, 0x05, 0x00, 0x73, 0x02, 0x00, 0x80},
     7,
     VFYBADUTF8,
     "nested bad utf8"},

    // Nested tuple with bad term inside
    // tuple( term("!") )
    {{0x70, 0x05, 0x00, 0x74, 0x02, 0x00, '!'},
     7,
     VFYBADTERM,
     "nested bad term"},

    // Nested tuple with NaN float inside
    // tuple( float(NaN) )
    {{0x70, 0x06, 0x00, 0x66, 0x03, 0x00, 0x7f, 0xf8},
     8,
     VFYBADFL,
     "nested NaN"},

    // Valid nested structure: tuple( int(1), string("x") )
    {{0x70, 0x09, 0x00, 0x69, 0x02, 0x00, 0x02, 0x73, 0x02, 0x00, 'x'},
     11,
     OK,
     "nested valid"},

    // Sentinel
    {{0}, 0, 0, NULL},
};

// Roundtrip test: TLV -> JDR -> TLV should produce identical bytes
// This is the key invariant for valid RDX data
fun ok64 VFYroundtrip(u8c const* data, u8 len, char const* desc) {
    sane(data && len > 0);

    // Buffers for intermediate JDR and final TLV
    a_pad(u8, jdr_buf, PAGESIZE);
    a_pad(u8, tlv_buf, PAGESIZE);

    // Step 1: TLV -> JDR
    rdx tlv_read = {.format = RDX_FMT_TLV};
    u8cs tlv_in = {data, data + len};
    u8csMv(tlv_read.data, tlv_in);

    rdx jdr_write = {.format = RDX_FMT_JDR | RDX_FMT_WRITE};
    u8sFork(jdr_buf_idle, jdr_write.into);

    ok64 o = rdxCopy(&jdr_write, &tlv_read);
    if (o != OK) {
        trace("FAIL[rt] %s: TLV->JDR copy failed: %s\n", desc, ok64str(o));
        return o;
    }
    call(u8sJoin, jdr_buf_idle, jdr_write.into);

    // Step 2: JDR -> TLV
    rdx jdr_read = {.format = RDX_FMT_JDR};
    u8csFork(jdr_buf_datac, jdr_read.data);

    rdx tlv_write = {.format = RDX_FMT_TLV | RDX_FMT_WRITE};
    u8sFork(tlv_buf_idle, tlv_write.into);

    o = rdxCopy(&tlv_write, &jdr_read);
    if (o != OK) {
        trace("FAIL[rt] %s: JDR->TLV copy failed: %s\n", desc, ok64str(o));
        return o;
    }
    call(u8sJoin, tlv_buf_idle, tlv_write.into);

    // Step 3: Compare original TLV with roundtripped TLV
    u8cs original = {data, data + len};
    if ($len(tlv_buf_datac) != $len(original)) {
        trace("FAIL[rt] %s: length mismatch: orig=%zu, got=%zu\n", desc,
              $len(original), $len(tlv_buf_datac));
        return TESTfail;
    }

    if (memcmp(*original, *tlv_buf_datac, len) != 0) {
        trace("FAIL[rt] %s: content mismatch\n", desc);
        trace("  orig: ");
        for (u8 i = 0; i < len; i++) trace("%02x ", data[i]);
        trace("\n  got:  ");
        for (size_t i = 0; i < $len(tlv_buf_datac); i++)
            trace("%02x ", tlv_buf_datac[0][i]);
        trace("\n");
        return TESTfail;
    }

    trace("PASS[rt] %s\n", desc);
    done;
}

ok64 VERIFYtest() {
    sane(1);

    // Test rdxVerify (single element)
    for (int i = 0; VERIFY_CASES[i].desc != NULL; i++) {
        VFYcase const* tc = &VERIFY_CASES[i];

        // Setup iterator with test data
        u8c const* data = tc->data;
        u8cs slice = {data, data + tc->len};

        rdx it = {.format = RDX_FMT_TLV};
        u8csMv(it.data, slice);

        // Parse the element first
        ok64 parse_result = rdxNext(&it);

        ok64 result;
        if (parse_result != OK) {
            // Parse failed - use parse error as result
            result = parse_result;
        } else {
            // Parse succeeded - verify current element
            result = rdxVerify(&it);
        }

        // Check result matches expectation
        if (result != tc->expect) {
            trace("FAIL[%d] %s: got %s", i, tc->desc, ok64str(result));
            trace(", want %s\n", ok64str(tc->expect));
            fail(TESTfail);
        }
        trace("PASS[%d] %s\n", i, tc->desc);
    }

    // Test rdxVerifyAll (sequences with nesting)
    for (int i = 0; VERIFYALL_CASES[i].desc != NULL; i++) {
        VFYcase const* tc = &VERIFYALL_CASES[i];

        u8c const* data = tc->data;
        u8cs slice = {data, data + tc->len};

        rdx it = {.format = RDX_FMT_TLV};
        u8csMv(it.data, slice);

        ok64 result = rdxVerifyAll(&it);

        if (result != tc->expect) {
            trace("FAIL[all:%d] %s: got %s", i, tc->desc, ok64str(result));
            trace(", want %s\n", ok64str(tc->expect));
            fail(TESTfail);
        }
        trace("PASS[all:%d] %s\n", i, tc->desc);
    }

    // Test roundtrip: valid TLV -> JDR -> TLV should be identical
    // Only test cases that pass verification (expect == OK)
    for (int i = 0; VERIFY_CASES[i].desc != NULL; i++) {
        VFYcase const* tc = &VERIFY_CASES[i];
        if (tc->expect != OK) continue;

        ok64 o = VFYroundtrip(tc->data, tc->len, tc->desc);
        if (o != OK) fail(TESTfail);
    }

    // Also test the valid nested cases
    for (int i = 0; VERIFYALL_CASES[i].desc != NULL; i++) {
        VFYcase const* tc = &VERIFYALL_CASES[i];
        if (tc->expect != OK) continue;

        ok64 o = VFYroundtrip(tc->data, tc->len, tc->desc);
        if (o != OK) fail(TESTfail);
    }

    done;
}

TEST(VERIFYtest);
