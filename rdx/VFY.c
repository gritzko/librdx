//
// rdxVerify - RDX structure and value verification
//
#include <math.h>

#include "RDX.h"
#include "abc/01.h"
#include "abc/PRO.h"

// Verification error codes (generated by ok64 utility)
con ok64 VFYBADTYPE = 0x7cf88b28d76264e;  // bad TLV type literal
con ok64 VFYBADLEN = 0x1f3e22ca355397;    // bad record length
con ok64 VFYBADUTF8 = 0x7cf88b28d79d3c8;  // invalid UTF-8
con ok64 VFYBADTERM = 0x7cf88b28d74e6d6;  // invalid term (non-Base64)
con ok64 VFYBADINT = 0x1f3e22ca3525dd;    // invalid integer encoding
con ok64 VFYBADFL = 0x7cf88b28d3d5;       // NaN or invalid float
con ok64 VFYBADREF = 0x1f3e22ca35b38f;    // invalid reference
con ok64 VFYBADNEST = 0x7cf88b28d5ce71d;  // bad nesting
con ok64 VFYBADORD = 0x1f3e22ca3586cd;    // incorrect element order

// RON Base64 alphabet validation
// Valid chars: 0-9 A-Z _ a-z ~
fun b8 VFYisBase64(u8 c) {
    if (c >= '0' && c <= '9') return YES;
    if (c >= 'A' && c <= 'Z') return YES;
    if (c >= 'a' && c <= 'z') return YES;
    if (c == '_' || c == '~') return YES;
    return NO;
}

// Validate term contains only RON Base64 characters, is non-empty,
// and doesn't start with a digit (would be ambiguous with integers in JDR)
fun ok64 VFYterm(u8cs term) {
    sane(u8csOK(term));
    if ($empty(term)) return VFYBADTERM;  // Terms cannot be empty
    // Terms cannot start with digit (ambiguous with integers in JDR)
    if (**term >= '0' && **term <= '9') return VFYBADTERM;
    $for(u8c, p, term) {
        if (!VFYisBase64(*p)) return VFYBADTERM;
    }
    done;
}

// Validate string with given encoding
// For escaped encodings, decode first then validate the result
fun ok64 VFYstring(u8cs str, u8 enc) {
    sane(u8csOK(str));

    if (enc == RDX_UTF_ENC_UTF8) {
        // Pure UTF-8: validate directly using abc/UTF8.h
        a_dup(u8c, s, str);
        ok64 o = utf8sValid(s);
        if (o != OK) return VFYBADUTF8;
        done;
    }

    if (enc >= RDX_UTF_ENC_LEN) {
        return VFYBADUTF8;  // Unknown encoding
    }

    // For escaped encodings, decode and validate
    // UTF8_DECODER_ALL decodes entire string
    UTFRecode decoder = UTABLE[enc][UTF8_DECODER_ALL];
    if (decoder == NULL) return VFYBADUTF8;

    // Decode into temporary buffer and validate
    a_pad(u8, decoded, PAGESIZE);
    a_dup(u8c, from, str);

    ok64 o = OK;
    while (!$empty(from) && o == OK) {
        o = decoder(decoded_idle, from);
        if (o == NOROOM) {
            // Validate what we have so far
            a_dup(u8c, check, decoded_datac);
            ok64 v = utf8sValid(check);
            if (v != OK) return VFYBADUTF8;
            u8bReset(decoded);
            o = OK;
        }
    }

    if (o != OK && o != END) return VFYBADUTF8;

    // Validate final decoded content
    if (!u8bEmpty(decoded)) {
        a_dup(u8c, check, decoded_datac);
        ok64 v = utf8sValid(check);
        if (v != OK) return VFYBADUTF8;
    }

    done;
}

// Check if float is NaN or Infinity
fun b8 VFYisNaN(f64 f) { return isnan(f); }
fun b8 VFYisInf(f64 f) { return isinf(f); }

// 60-bit limit for ref/id values (10 Base64 symbols, upper 4 bits reserved)
#define VFY_MAX_60BIT 0x0FFFFFFFFFFFFFFFUL

// Verify the current element of a parsed iterator
// Does NOT recurse into containers or iterate
ok64 rdxVerify(rdxp x) {
    sane(x);

    // Check type is valid
    if (x->type == 0) return OK;  // No element
    if (x->type >= RDX_TYPE_LEN) return VFYBADTYPE;

    // Check id is within 60-bit limit
    if (x->id.seq > VFY_MAX_60BIT || x->id.src > VFY_MAX_60BIT)
        return VFYBADREF;

    // Verify based on type
    switch (x->type) {
        case RDX_TYPE_FLOAT: {
            // Check for NaN or Infinity (not allowed, like JSON)
            if (VFYisNaN(x->f) || VFYisInf(x->f)) return VFYBADFL;
            break;
        }

        case RDX_TYPE_INT:
            break;

        case RDX_TYPE_REF:
            // Check ref value is within 60-bit limit
            if (x->r.seq > VFY_MAX_60BIT || x->r.src > VFY_MAX_60BIT)
                return VFYBADREF;
            break;

        case RDX_TYPE_STRING: {
            // Validate UTF-8 with appropriate encoding
            call(VFYstring, x->s, x->cformat);
            break;
        }

        case RDX_TYPE_TERM: {
            // Validate Base64
            call(VFYterm, x->t);
            break;
        }

        case RDX_TYPE_TUPLE:
        case RDX_TYPE_LINEAR:
        case RDX_TYPE_EULER:
        case RDX_TYPE_MULTIX:
            // Container types: valid at this level
            break;

        default:
            return VFYBADTYPE;
    }

    done;
}

// Verify entire sequence including nested elements
// Pattern follows rdxCopy
ok64 rdxVerifyAll(rdxp from) {
    sane(from && !rdxWritable(from));
    scan(rdxNext, from) {
        call(rdxVerify, from);
        if (rdxTypePlex(from)) {
            rdx cfrom = {};
            call(rdxInto, &cfrom, from);
            call(rdxVerifyAll, &cfrom);
            call(rdxOuto, &cfrom, from);
        }
    }
    seen(END);
    done;
}
